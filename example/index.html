<!DOCTYPE html>
<html lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
	<title>walnut javascript example</title>
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
	<link type="text/css" rel="stylesheet" href="main.css?_8">
	<script src="Three.jscad.js"></script>
	<script src="jscad-modeling.min.js"></script>
	<script src="walnut-javascript.js"></script>
</head>
<body>
<div id="renderIndicator">R</div>

</body>
<script type="text/javascript">

	
let scene, camera, controls, mesh, grid, ground, meshes=[];
let renderer
let SHADOW = false
let CAM_DISTANCE = 100
let shouldRender = Date.now()
let lastRender = true
let firstRender = true
let jscad = jscadModeling
let $w = walnutJavascript
$w.onRuntimeInitialized = ()=>{
	console.log('walnutJavascript.onRuntimeInitialized')
	testWalnut();
}
init();
animate();


function init() {

	camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 1, 50000 );
	let oldCamera = localStorage.getItem('camera')
	camera.position.set( 180, -180, 220 );
	if(oldCamera){
		oldCamera = JSON.parse(oldCamera)
		let pos = oldCamera.position
		if(pos)	camera.position.set( pos.x, pos.y, pos.z );
	}
	camera.up.set( 0, 0, 1 );

	scene = new THREE.Scene();
	scene.background = new THREE.Color( 0xffffff );
	//scene.fog = new THREE.Fog( 0xffffff, 200, 1000 );
	//

	const hemiLight = new THREE.HemisphereLight( 0xffffff, 0x444444 );
	hemiLight.position.set( 0, 0, 2000 );
	scene.add( hemiLight );

	const directionalLight = new THREE.DirectionalLight( 0xffffff );
	directionalLight.position.set( 0, 200, 100 );
	directionalLight.castShadow = SHADOW;
	if(SHADOW){				
		directionalLight.shadow.camera.top = 180;
		directionalLight.shadow.camera.bottom = - 100;
		directionalLight.shadow.camera.left = - 120;
		directionalLight.shadow.camera.right = 120;
	}
	scene.add( directionalLight );

	// ground

	ground = new THREE.Mesh( new THREE.PlaneBufferGeometry( 200, 200 ), new THREE.MeshPhongMaterial( { color: 0xffffff, depthWrite: false } ) );
	// ground.rotation.x =  - Math.PI / 2;
	// ground.rotation.y =  - Math.PI / 2;
	ground.receiveShadow = SHADOW;
	scene.add( ground );

	grid = new THREE.GridHelper( 200, 20, 0x000000, 0x000000 );
	grid.rotation.x = - Math.PI / 2;
	// grid.rotation.y = - Math.PI / 2;
	grid.material.opacity = 0.2;
	grid.material.transparent = true;
	scene.add( grid );


	grid2 = new THREE.GridHelper( 200, 200, 0x000000, 0x000000 );
	grid2.rotation.x = - Math.PI / 2;
	// grid.rotation.y = - Math.PI / 2;
	grid2.material.opacity = 0.1;
	grid2.material.transparent = true;
	scene.add( grid2 );

	let axes = new THREE.AxesHelper( 10 );
	scene.add( axes );

	renderer = new THREE.WebGLRenderer( { antialias: true, preserveDrawingBuffer : true } )
	
	// renderer = new SVGRenderer( { overdraw:0.1 } );
	renderer.setPixelRatio( window.devicePixelRatio );
	onWindowResize()
	//renderer.shadowMap.enabled = SHADOW;
	document.body.appendChild( renderer.domElement );

	//

	controls = new THREE.OrbitControls( camera, renderer.domElement );
	controls.target.set( 0, 0, 0 );
	if(oldCamera){
		let pos = oldCamera.target
		if(pos) controls.target.set( pos.x, pos.y, pos.z );
	}

	controls.update();
	controls.addEventListener('change',function(){
		moveshouldRender()
	})

	//

	window.addEventListener( 'resize', onWindowResize, false );
	let body = document.body


	// body.addEventListener( 'mousemove', moveshouldRender );
	// body.addEventListener( 'mousedown', moveshouldRender );
	// body.addEventListener( 'drag', moveshouldRender );
	// body.addEventListener( 'dragover', moveshouldRender );
	function addClick(id,func){
		const button = document.getElementById( id );
		button.addEventListener( 'click', func );
	}
}

function clearScene(){
	scene.remove(...meshes);
	meshes.forEach(m=>m?.geometry?.dispose())
	meshes.length=0;
	moveshouldRender()			
}

function setMeshes(_meshes){
	clearScene()
	_meshes.forEach(m=>{
		scene.add(m)
		meshes.push(m)
	})
}

function animate() {
	requestAnimationFrame( animate )
	if(!shouldRender){
		if(lastRender){
			setVisible('renderIndicator', lastRender = false)
		}
		return;
	} 
	if(!lastRender){
		setVisible('renderIndicator', lastRender = true)
	}
	let time = firstRender ?  performance.now() : 0
	firstRender = false
	shouldRender = controls.autoRotate
    controls.update();
    localStorage.setItem('camera', JSON.stringify({position:camera.position, target: controls.target}))
	renderer.render( scene, camera );
	if(time) {
		firstRenderMsg = 'first render '+(performance.now() - time).toFixed(2)
	}
}

function onWindowResize() {
	moveshouldRender()
	camera.aspect = window.innerWidth / window.innerHeight;
	camera.updateProjectionMatrix();
	renderer.setSize( window.innerWidth, window.innerHeight )
}


function moveshouldRender(offset = 500){
	shouldRender = true
}

function setVisible(id, v){
	let elem = document.getElementById(id)
	if(elem) elem.style.display = v ? 'initial':'none'
	else console.log('setVisible: elem not found',id)
}

const flatShading = true
const materials = {
	mesh: {
		def: new THREE.MeshPhongMaterial( { color: 0x0084d1, flatShading } ),
		make: (params)=>new THREE.MeshPhongMaterial({flatShading, ...params}),
	},
	line: {
		def: new THREE.LineBasicMaterial( { color: 0x0000ff } ),
		make: ({color,opacity,transparent})=>new THREE.LineBasicMaterial({color,opacity,transparent}),
	},
  lines:null
}
materials.lines = materials.line			

function CSG2Object3D(obj){
	const {vertices, indices, color, transforms} = obj

	let materialDef = materials[obj.type || 'mesh']
	let material = materialDef.def
	let isInstanced = obj.type == 'instances'
	if(color && !isInstanced){
		let c = color
		material = materialDef.make({ color: CSG2Object3D.makeColor(color), flatShading, opacity: c[3] === void 0 ? 1:c[3], transparent: c[3] != 1 && c[3] !== void 0})
	}

	var geo = new THREE.BufferGeometry()
	geo.setAttribute('position', new THREE.BufferAttribute(vertices,3))

	var mesh;
	switch(obj.type || 'mesh'){
		case 'mesh': geo.setIndex(new THREE.BufferAttribute(indices,1)); mesh = new THREE.Mesh(geo, material); break;
		case 'instances':
			geo.setIndex(new THREE.BufferAttribute(indices,1))
			mesh = new THREE.InstancedMesh(geo, materials.mesh.make( { color: 0x0084d1 } ))
			transforms = null
			break;
		case 'line': mesh = new THREE.Line(geo, material); break;
		case 'lines': mesh = new THREE.LineSegments(geo, material); break;
	}
	if(transforms && !isInstanced) mesh.applyMatrix4({elements:transforms})
	return mesh
}

CSG2Object3D.makeColor = c=>new THREE.Color(c[0],c[1],c[2])
CSG2Object3D.materials = materials

function makeCube({size, tx=0, ty=0, tz=0}){
	let vLen = 12
	let px = size[0]/2
	let py = size[1]/2
	let pz = size[2]/2
	let vertices = new Float32Array(vLen * 3 * 3)
	let indices = new Uint16Array(vLen * 3)
	let polygons = []

	let vertOffset = 0
	let posOffset = 0

	let p0 = [-px+tx,-py+ty,-pz+tz]
	let p1 = [ px+tx,-py+ty,-pz+tz]
	let p2 = [ px+tx, py+ty,-pz+tz]
	let p3 = [-px+tx, py+ty,-pz+tz]
	let p4 = [-px+tx,-py+ty, pz+tz]
	let p5 = [ px+tx,-py+ty, pz+tz]
	let p6 = [ px+tx, py+ty, pz+tz]
	let p7 = [-px+tx, py+ty, pz+tz]

	function addPoly(...arr){
		polygons.push(arr)
    	let len = arr.length
    	
    	vertices.set(arr[0], vertOffset)
    	indices[posOffset] = posOffset++
    	vertOffset +=3
    	
    	vertices.set(arr[1], vertOffset)
    	indices[posOffset] = posOffset++
    	vertOffset +=3

    	vertices.set(arr[2], vertOffset)
    	indices[posOffset] = posOffset++
    	vertOffset +=3

    	for(let i=3; i<len; i+=3){
			vertices.set(arr[0], vertOffset)
			indices[posOffset] = posOffset++
			vertOffset +=3
			
			vertices.set(arr[i-1], vertOffset)
			indices[posOffset] = posOffset++
			vertOffset +=3

			vertices.set(arr[i], vertOffset)
			indices[posOffset] = posOffset++
			vertOffset +=3
    	}
	}

	addPoly(p3,p2,p1,p0)
	addPoly(p4,p5,p6,p7)

	addPoly(p0,p1,p5,p4)
	addPoly(p7,p6,p2,p3)
	
	addPoly(p1,p2,p6,p5)
	addPoly(p0,p4,p7,p3)

	return {indices, vertices, type: 'mesh', polygons}
}


/*
To use it, first call AllocateDoubleVertexArray to allocate a buffer. It returns a pointer back, which should look like an integer in Javascript land.
In JavaScript create a typed array on the webasm's memory starting at the returned pointer.
Fill in the vertices using JavaScript.
Call AllocateTempVertexBuffer and remember the result for passing into AddPolygonToMesh later.
Call AllocateMesh a total of 3 times. Twice for the two input meshes, and once for an output mesh.
Call AddPolygonToMesh at least once for each of the input meshes.
Call UnionMeshes and give it the 3 meshes.
Use GetPolygonCount, GetPolygonVertexCount, and GetPolygonVertices to read the results out of the output mesh.
*/

let polyBuffer
let tmpBuffer

function resizePolyBuffer(){
	polyBuffer.free()
	polyBuffer = w_AllocateFloatVertexArray(polyBuffer.vertexCount*2)
	console.log('resizing poly buffer',polyBuffer.vertexCount*2)
}

function w_AllocateFloatVertexArray(vertexCount){
	let vertexPointer = $w._AllocateFloatVertexArray(/*max_vertices=*/vertexCount)
	let vertices = $w.HEAPF32.subarray(vertexPointer/4, vertexPointer/4 + vertexCount*3)
	vertices.vertexPointer = vertexPointer
	vertices.vertexCount = vertexCount
	vertices.free = ()=> $w._FreeFloatVertexArray(vertexPointer)
	return vertices	
}

function toWalnut(obj){
	if(obj.transforms && !jscad.maths.mat4.isIdentity(obj.transforms)) return toWalnutTransformed(obj)
	let vertexCount = 0
	obj.polygons.forEach(p=>vertexCount += p.length)
	let mesh = $w._AllocateMesh(vertexCount)

	obj.polygons.forEach(p=>{
		if(p.vertices) p = p.vertices // jscad format
		let count = 0
		p.forEach(v=>{
			polyBuffer.set(v, count)// count is also offset
			count += 3
		})
		$w._AddFloatPolygonToMesh(count/3, polyBuffer.vertexPointer, tmpBuffer, mesh, -8)
	})
	mesh.vertexCount = vertexCount	
	return mesh
}

// apply transform during conversion to walnut internal model
function toWalnutTransformed(obj){
	let { transforms } = obj
	let vertexCount = 0
	obj.polygons.forEach(p=>vertexCount += p.length)
	let mesh = $w._AllocateMesh(vertexCount)

	let v = [0,0,0]
	obj.polygons.forEach(p=>{
		if(p.vertices) p = p.vertices // jscad format
		let count = 0
		p.forEach(vIn=>{
			jscad.maths.vec3.transform(v,vIn,transforms)
			polyBuffer.set(v, count)// count is also offset
			count += 3
		})
		$w._AddFloatPolygonToMesh(count/3, polyBuffer.vertexPointer, tmpBuffer, mesh, -8)
	})
	mesh.vertexCount = vertexCount	
	return mesh
}

// convert to walnut but inverted when needed for example in subtract
function toWalnutInv(obj){
	if(obj.transforms && !jscad.maths.mat4.isIdentity(obj.transforms)) return toWalnutInvTransformed(obj)
	let vertexCount = 0
	obj.polygons.forEach(p=>vertexCount += p.length)
	let mesh = $w._AllocateMesh(vertexCount)

	obj.polygons.forEach(p=>{
		if(p.vertices) p = p.vertices // jscad format
		let count = 0
		for(let i=p.length-1; i>=0; i--){
			let v = p[i]
			polyBuffer.set(v, count)// count is also offset
			count += 3
		}
		$w._AddFloatPolygonToMesh(count/3, polyBuffer.vertexPointer, tmpBuffer, mesh, -8)
	})
	mesh.vertexCount = vertexCount
	return mesh
}

// convert to walnut but inverted when needed for example in subtract
// also apply transform during conversion to walnut internal model
function toWalnutInvTransformed(obj){
	let { transforms } = obj
	let vertexCount = 0
	obj.polygons.forEach(p=>vertexCount += p.length)
	let mesh = $w._AllocateMesh(vertexCount)

	let v = [0,0,0]
	obj.polygons.forEach(p=>{
		if(p.vertices) p = p.vertices // jscad format
		let count = 0
		for(let i=p.length-1; i>=0; i--){
			jscad.maths.vec3.transform(v,p[i],transforms)
			polyBuffer.set(v, count)// count is also offset
			count += 3
		}
		$w._AddFloatPolygonToMesh(count/3, polyBuffer.vertexPointer, tmpBuffer, mesh, -8)
	})
	mesh.vertexCount = vertexCount
	return mesh
}

function toWalnutOldVertexOnly(obj){
	let vertexCount = obj.vertices.length / 3

	let vertexPointer = $w._AllocateFloatVertexArray(/*max_vertices=*/vertexCount)
	let vertices = $w.HEAPF32.subarray(vertexPointer/4, vertexPointer/4 + vertexCount*3)

	// this is form js api, it will copy all elements from one array to other
	// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/set
	vertices.set(obj.vertices)

	let triangleCount = vertexCount / 3
	let mesh = $w._AllocateMesh(triangleCount)
	$w._AddFloatTrianglesToMesh(triangleCount, vertexPointer, mesh, -8)
	$w._FreeFloatVertexArray(vertexPointer)
	return mesh
}

function toGeom(mesh){
	let triangleCount = $w._GetTriangleCountInMesh(mesh)
	let vertexCount = triangleCount * 3
	let vertexPointer = $w._AllocateFloatVertexArray(vertexCount)
	$w._GetFloatTrianglesFromMesh(mesh, vertexPointer)

	let vertices = new Float32Array(vertexCount * 3)
	vertices.set($w.HEAPF32.subarray(vertexPointer/4, vertexPointer/4 + vertexCount*3))
	let indices = new Uint16Array(vertexCount * 3)
	for (let i = 0; i < vertexCount; ++i) {
		indices[i] = i
	}
	$w._FreeFloatVertexArray(vertexPointer)
	return {indices, vertices, type: 'mesh'}
}

function subtract(geom1, geom2){
	console.log('subtract',geom1, geom2);
	if(geom2 instanceof Array) geom2 = geom2[0] // temporary fix for transalte
	let wMesh1 = toWalnut(geom1)
	let wMesh2 = toWalnutInv(geom2)

	let wResult = $w._AllocateMesh(wMesh1.vertexCount)

	let filterSuccess = $w._SubtractMesh(wMesh1, wMesh2, wResult)

	let result = toGeom(wResult)
	console.log('filter result', filterSuccess, result)

	$w._FreeMesh(wMesh1)
	$w._FreeMesh(wMesh2)
	$w._FreeMesh(wResult)
	return result
}


/********************** test walnut func  *****************/

function testWalnut(){
	polyBuffer = w_AllocateFloatVertexArray(4096)
	tmpBuffer = $w._AllocateTempVertexBuffer()

	// uncomment one of examples
	// let result = subtractCubes()
	// let result = subtractCubesJscad()
	let result = subtractSpheresJscad(12)

	// display in threejs
	let mesh1 = CSG2Object3D(result)
	setMeshes([mesh1])
}


function subtractCubes(){
	return subtract(
		makeCube({size:[10,10,10]}),
		makeCube({size:[10,10,10], tx:5,ty:5,tz:5}),
	)
}

const { cube, sphere } = jscad.primitives
const { translate } = jscad.transforms

function subtractCubesJscad(){
	let out = subtract(
		cube({size:10}),
		translate([5,5,5],cube({size:10})),
	)
	return out
}

function subtractSpheresJscad(segments=32){
	let out = subtract(
		sphere({radius:10, segments}),
		translate([5,5,5],sphere({radius:10, segments})),
	)
	return out
}

</script>
<script src="http://localhost:35700/livereload.js?snipver=1"></script>
